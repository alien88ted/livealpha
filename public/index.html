<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiveAlpha</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #fafafa;
            --surface: #ffffff;
            --border: #e8e8e8;
            --text: #0a0a0a;
            --text-dim: #666666;
            --text-subtle: #999999;
            --accent: #000000;
            --green: #00c851;
            --orange: #ff6600;
            --red: #dc3545;
            --blue: #0066cc;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0a0a0a;
                --surface: #1a1a1a;
                --border: #2a2a2a;
                --text: #ffffff;
                --text-dim: #b3b3b3;
                --text-subtle: #666666;
                --accent: #ffffff;
                --green: #00ff88;
                --orange: #ff8833;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
            background: var(--bg);
            color: var(--text);
            font-size: 15px;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            margin-bottom: 60px;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 800;
            letter-spacing: -0.02em;
            color: var(--text);
            margin-bottom: 8px;
        }

        .header .subtitle {
            font-size: 16px;
            color: var(--text-dim);
            font-weight: 400;
        }

        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 50px;
        }

        .status-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-dim);
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 13px;
            color: var(--text-subtle);
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .live-indicator {
            width: 6px;
            height: 6px;
            background: var(--green);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1px;
            background: var(--border);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 50px;
        }

        .stat-card {
            background: var(--surface);
            padding: 24px 20px;
            text-align: center;
            position: relative;
        }

        .stat-card:hover {
            background: var(--bg);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-subtle);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .ai-status-idle {
            color: var(--text-subtle) !important;
        }

        .ai-status-active {
            color: var(--green) !important;
        }

        .ai-status-processing {
            color: var(--orange) !important;
            animation: fade 1.5s infinite;
        }

        @keyframes fade {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .insights-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .insights-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .insights-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }

        .ai-status-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: var(--bg);
            border-radius: 8px;
            font-size: 13px;
        }

        .ai-model-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-model-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-subtle);
        }

        .ai-model-indicator.active {
            background: var(--green);
            animation: pulse 2s infinite;
        }

        .ai-model-indicator.processing {
            background: var(--orange);
            animation: fade 1s infinite;
        }

        .ai-model-indicator.error {
            background: var(--red);
        }

        .ai-timestamp {
            color: var(--text-subtle);
            font-size: 11px;
        }

        .toggle-btn {
            background: var(--text);
            color: var(--surface);
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .toggle-btn:hover {
            opacity: 0.8;
        }

        .tickers {
            display: flex;
            gap: 6px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .ticker {
            background: var(--border);
            color: var(--text);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            font-family: "SF Mono", Monaco, monospace;
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .ticker-price {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-dim);
        }

        .ticker-change {
            font-size: 9px;
            font-weight: 500;
        }

        .ticker-change.positive {
            color: var(--green);
        }

        .ticker-change.negative {
            color: var(--red);
        }

        .price-loading {
            opacity: 0.6;
            animation: fade 1.5s infinite;
        }

        .headline {
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-dim);
        }

        .filters-section {
            margin-bottom: 30px;
        }

        .filters-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 12px;
            color: var(--text-subtle);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .filter-item {
            position: relative;
        }

        .filter-item input[type="checkbox"] {
            display: none;
        }

        .filter-item label {
            display: inline-block;
            padding: 8px 16px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            color: var(--text-dim);
            transition: all 0.15s ease;
        }

        .filter-item input[type="checkbox"]:checked + label {
            background: var(--text);
            color: var(--surface);
            border-color: var(--text);
        }

        .filter-item label:hover {
            border-color: var(--text-dim);
        }

        .filter-item input[type="checkbox"]:checked + label:hover {
            background: var(--text-dim);
        }

        /* Webhook Configuration Styles */
        .webhook-status {
            font-size: 14px;
            color: var(--text-dim);
        }

        .webhook-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg);
            color: var(--text);
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.15s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--text);
        }

        .form-input::placeholder {
            color: var(--text-subtle);
        }

        .webhook-options,
        .webhook-accounts {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .webhook-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .webhook-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--text);
        }

        .webhook-option label {
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            color: var(--text-dim);
        }

        .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .test-btn {
            background: var(--bg);
            color: var(--text-dim);
        }

        .save-btn {
            background: var(--green);
            color: white;
            border-color: var(--green);
        }

        .save-btn:hover {
            background: var(--text);
            border-color: var(--text);
        }

        .tweets-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        .tweet {
            border-bottom: 1px solid var(--border);
            padding: 30px;
            transition: background-color 0.15s;
        }

        .tweet:last-child {
            border-bottom: none;
        }

        .tweet:hover {
            background: var(--bg);
        }

        .new-tweet {
            border-left: 3px solid var(--green);
            background: var(--bg);
        }

        .test-tweet {
            border-left: 3px solid var(--blue);
        }

        .tweet-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .tweet-author {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alpha-badge {
            background: var(--text);
            color: var(--surface);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .test-badge {
            background: var(--blue);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .username {
            font-weight: 600;
            font-size: 15px;
            color: var(--text);
        }

        .tweet-meta {
            font-size: 13px;
            color: var(--text-subtle);
            margin-bottom: 12px;
        }

        .tweet-actions {
            display: flex;
            gap: 6px;
        }

        .action-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .action-btn:hover {
            background: var(--text);
            color: var(--surface);
        }

        .tweet-text {
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 16px;
            color: var(--text);
        }

        .tweet-metrics {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: var(--text-subtle);
        }

        .metric {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .error-state,
        .loading-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-dim);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 16px;
            }

            .header {
                margin-bottom: 40px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .stat-card {
                padding: 20px 16px;
            }

            .insights-card {
                padding: 20px;
                margin-bottom: 24px;
            }

            .filter-group {
                gap: 6px;
            }

            .filter-item label {
                padding: 6px 12px;
                font-size: 12px;
            }

            .tweet {
                padding: 24px 20px;
            }

            .tweet-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px 12px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LiveAlpha</h1>
            <div class="subtitle">Real-time Twitter insights & alpha tracking</div>
        </div>

        <div class="status-bar">
            <div class="status-left">
                <div class="live-indicator"></div>
                <span id="connectionStatus">Starting</span>
            </div>
            <div class="status-right">
                <div class="system-status" id="systemStatus" style="display: none;">
                    <span id="planType"></span>
                    <span id="usagePercent"></span>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="totalTweets">0</div>
                <div class="stat-label">Total</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="alphaTweets">0</div>
                <div class="stat-label">Alpha</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="testTweets">0</div>
                <div class="stat-label">Test</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="activeAccounts">0</div>
                <div class="stat-label">Accounts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="apiUsage">0%</div>
                <div class="stat-label">API Usage</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="queueLength">0</div>
                <div class="stat-label">Queue</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="aiPhase">‚óè</div>
                <div class="stat-label">AI</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">
                    <a id="memoryLink" href="#" style="color: var(--accent-blue); text-decoration: none;">Memory</a>
                </div>
                <div class="stat-label">AI Memory</div>
            </div>
        </div>

        <div class="insights-card">
            <div class="insights-header">
                <div class="insights-title">
                    Alpha Insights
                </div>
                <button id="aiToggle" class="toggle-btn">Details</button>
            </div>

            <div class="ai-status-bar">
                <div class="ai-model-status">
                    <div class="ai-model-indicator" id="opusIndicator"></div>
                    <span>Opus</span>
                    <span class="ai-timestamp" id="opusTimestamp">Never run</span>
                </div>
                <div class="ai-model-status">
                    <div class="ai-model-indicator" id="haikuIndicator"></div>
                    <span>Haiku</span>
                    <span class="ai-timestamp" id="haikuTimestamp">Never run</span>
                </div>
                <div class="ai-model-status">
                    <div class="ai-model-indicator" id="sonnetIndicator"></div>
                    <span>Sonnet</span>
                    <span class="ai-timestamp" id="sonnetTimestamp">Never run</span>
                </div>
                <div style="margin-left: auto; font-size: 11px; color: var(--text-subtle);">
                    Daily: $<span id="aiDailyCost">0.00</span> / $<span id="aiDailyBudget">10.00</span>
                </div>
            </div>

            <div id="aiCompact">
                <div class="tickers" id="aiTickersContainer"></div>
                <div class="headline" id="aiHeadline">Analyzing market activity...</div>
            </div>
            <div id="aiInsights" style="display:none; margin-top:16px; padding:16px; background:var(--bg); border-radius:8px; font-size:14px; line-height:1.5; color: var(--text-dim);"></div>
        </div>


        <div class="filters-section">
            <div class="filters-title">Accounts</div>
            <div class="filter-group">
                <div class="filter-item">
                    <input type="checkbox" id="filter-cz_binance" checked>
                    <label for="filter-cz_binance">@cz_binance</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-justinsuntron" checked>
                    <label for="filter-justinsuntron">@justinsuntron</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-CookerFlips" checked>
                    <label for="filter-CookerFlips">@CookerFlips</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-ShockedJS" checked>
                    <label for="filter-ShockedJS">@ShockedJS</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-LabsNoor" checked>
                    <label for="filter-LabsNoor">@LabsNoor</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-peacefuldecay" checked>
                    <label for="filter-peacefuldecay">@peacefuldecay</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-0xpeely" checked>
                    <label for="filter-0xpeely">@0xpeely</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-km_trades" checked>
                    <label for="filter-km_trades">@km_trades</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-astaso1" checked>
                    <label for="filter-astaso1">@astaso1</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-eyearea" checked>
                    <label for="filter-eyearea">@eyearea</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-trading_axe" checked>
                    <label for="filter-trading_axe">@trading_axe</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-OwariETH" checked>
                    <label for="filter-OwariETH">@OwariETH</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-issathecooker" checked>
                    <label for="filter-issathecooker">@issathecooker</label>
                </div>
                <div class="filter-item">
                    <input type="checkbox" id="filter-alien88ted" checked>
                    <label for="filter-alien88ted">@alien88ted (TEST)</label>
                </div>
            </div>
        </div>

        <div class="insights-card">
            <div class="insights-header">
                <div class="insights-title">Discord Notifications</div>
                <button id="webhookToggle" class="toggle-btn">Configure</button>
            </div>
            <div id="webhookCompact">
                <div class="webhook-status" id="webhookStatus">Not configured</div>
            </div>
            <div id="webhookConfig" style="display:none; margin-top:20px;">
                <div class="webhook-form">
                    <div class="form-group">
                        <label for="webhookUrl" class="form-label">Webhook URL</label>
                        <input type="url" id="webhookUrl" class="form-input" placeholder="https://discord.com/api/webhooks/...">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Notification Types</label>
                        <div class="webhook-options">
                            <div class="webhook-option">
                                <input type="checkbox" id="notify-all-tweets" checked>
                                <label for="notify-all-tweets">All tweets</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="notify-ai-insights">
                                <label for="notify-ai-insights">AI insights</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="notify-high-engagement">
                                <label for="notify-high-engagement">High engagement (1K+ likes)</label>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Account Filter</label>
                        <div class="webhook-accounts" id="webhookAccounts">
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-cz_binance" checked>
                                <label for="webhook-cz_binance">@cz_binance</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-justinsuntron" checked>
                                <label for="webhook-justinsuntron">@justinsuntron</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-CookerFlips" checked>
                                <label for="webhook-CookerFlips">@CookerFlips</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-ShockedJS" checked>
                                <label for="webhook-ShockedJS">@ShockedJS</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-LabsNoor" checked>
                                <label for="webhook-LabsNoor">@LabsNoor</label>
                            </div>
                            <div class="webhook-option">
                                <input type="checkbox" id="webhook-peacefuldecay" checked>
                                <label for="webhook-peacefuldecay">@peacefuldecay</label>
                            </div>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button id="testWebhook" class="action-btn test-btn">Test</button>
                        <button id="saveWebhook" class="action-btn save-btn">Save</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="tweets-container">
            <div id="tweetsContent" class="loading-state">Loading tweets...</div>
        </div>

    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let allTweets = [];
        let accounts = new Set();
        let enabledAccounts = new Set(['cz_binance', 'justinsuntron', 'CookerFlips', 'ShockedJS', 'LabsNoor', 'peacefuldecay', '0xpeely', 'km_trades', 'astaso1', 'eyearea', 'trading_axe', 'OwariETH', 'issathecooker', 'alien88ted']);
        let priceCache = {};

        function parseDateUtc(value) {
            if (!value) return new Date();
            if (value instanceof Date) return value;
            const s = String(value);
            // If already ISO with T, trust it
            if (s.includes('T')) return new Date(s);
            // MySQL TIMESTAMP without TZ -> treat as UTC
            // Convert "YYYY-MM-DD HH:MM:SS" -> "YYYY-MM-DDTHH:MM:SSZ"
            return new Date(s.replace(' ', 'T') + 'Z');
        }

        function inferDateFromTweetId(id) {
            try {
                const EPOCH = 1288834974657n;
                const bid = BigInt(String(id));
                const ms = Number((bid >> 22n) + EPOCH);
                return new Date(ms);
            } catch { return new Date(); }
        }

        function formatTime(dateString, id) {
            let date = parseDateUtc(dateString);

            // Debug logging
            console.log(`formatTime: dateString="${dateString}", id="${id}"`);
            console.log(`parseDateUtc result:`, date, `isNaN:`, isNaN(date.getTime()));

            if (isNaN(date.getTime()) || !dateString) {
                console.log(`Using Tweet ID fallback for ${id}`);
                date = inferDateFromTweetId(id);
            }

            const now = new Date();
            let diff = Math.floor((now - date) / 1000);
            console.log(`Time diff: ${diff}s (${Math.floor(diff/60)}min)`);

            if (diff < 0) diff = 0; // clamp future timestamps from TZ drift

            if (diff < 60) return `${diff}s`;
            if (diff < 3600) return `${Math.floor(diff / 60)}m`;
            if (diff < 86400) return `${Math.floor(diff / 3600)}h`;
            return `${Math.floor(diff / 86400)}d`;
        }

        function formatNum(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        function updateAIStatus(aiData) {
            const aiElement = document.getElementById('aiPhase');
            const phase = aiData.phase || 'idle';
            const isRunning = aiData.running || false;

            // Remove all status classes
            aiElement.className = aiElement.className.replace(/ai-status-\w+/g, '');

            if (phase === 'idle') {
                if (aiData.idleReason && aiData.idleReason.includes('waiting')) {
                    aiElement.textContent = '‚óã';
                    aiElement.classList.add('ai-status-idle');
                } else {
                    aiElement.textContent = '‚óè';
                    aiElement.classList.add('ai-status-idle');
                }
            } else if (isRunning || phase.includes('processing') || phase.includes('analyzing')) {
                aiElement.textContent = '‚óè';
                aiElement.classList.add('ai-status-processing');
            } else if (phase.includes('active') || phase.includes('ready')) {
                aiElement.textContent = '‚óè';
                aiElement.classList.add('ai-status-active');
            } else {
                aiElement.textContent = '‚óè';
                aiElement.classList.add('ai-status-idle');
            }

            // Update model status indicators
            updateModelStatus('opus', aiData.lastOpusAt, phase === 'opus' && isRunning);
            updateModelStatus('haiku', aiData.lastHaikuDecisionAt || aiData.lastHaikuFlashAt, phase.includes('haiku') && isRunning);
            updateModelStatus('sonnet', aiData.lastSonnetAt, phase === 'sonnet' && isRunning);
        }

        async function updateAIUsageMetrics(aiUsageData) {
            if (aiUsageData && aiUsageData.current && aiUsageData.current.daily) {
                const dailySpend = aiUsageData.current.daily.totalSpend || 0;
                const dailyBudget = aiUsageData.current.daily.totalBudget || 10;

                document.getElementById('aiDailyCost').textContent = dailySpend.toFixed(2);
                document.getElementById('aiDailyBudget').textContent = dailyBudget.toFixed(2);
            }
        }

        function updateModelStatus(model, lastRun, isCurrentlyRunning) {
            const indicator = document.getElementById(`${model}Indicator`);
            const timestamp = document.getElementById(`${model}Timestamp`);

            // Clear existing classes
            indicator.className = 'ai-model-indicator';

            if (isCurrentlyRunning) {
                indicator.classList.add('processing');
            } else if (lastRun) {
                indicator.classList.add('active');
            }

            // Format timestamp
            if (lastRun) {
                const date = new Date(lastRun);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);

                let timeText;
                if (diffMins < 1) {
                    timeText = 'Just now';
                } else if (diffMins < 60) {
                    timeText = `${diffMins}m ago`;
                } else if (diffHours < 24) {
                    timeText = `${diffHours}h ago`;
                } else {
                    timeText = date.toLocaleDateString();
                }

                timestamp.textContent = timeText;
            } else {
                timestamp.textContent = 'Never run';
            }
        }

        function formatTimeAgo(dateString) {
            if (!dateString) return 'Never';
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Price fetching and display functions
        async function fetchPrices(tickers) {
            try {
                const response = await fetch(`/api/prices?tickers=${tickers.join(',')}`);
                if (response.ok) {
                    const data = await response.json();
                    Object.assign(priceCache, data.prices);
                    return data.prices;
                }
            } catch (error) {
                console.error('Error fetching prices:', error);
            }
            return {};
        }

        function renderTickerWithPrice(ticker) {
            const symbol = ticker.replace('$', '').toUpperCase();
            const priceData = priceCache[symbol];

            if (!priceData) {
                return `<span class="ticker price-loading">
                    ${ticker}
                    <span class="ticker-price">...</span>
                </span>`;
            }

            const changeClass = priceData.change24h >= 0 ? 'positive' : 'negative';

            return `<span class="ticker">
                ${ticker}
                <span class="ticker-price">${priceData.formattedPrice}</span>
                <span class="ticker-change ${changeClass}">${priceData.formattedChange}</span>
            </span>`;
        }

        async function updateTickerPrices(tickers) {
            if (!tickers || tickers.length === 0) return;

            // Fetch prices for new tickers
            const newTickers = tickers.filter(t => {
                const symbol = t.replace('$', '').toUpperCase();
                return !priceCache[symbol];
            });

            if (newTickers.length > 0) {
                await fetchPrices(newTickers);
            }
        }

        function compactFallbackFromContent(content) {
            if (!content) return { tickers: [], headline: '' };
            const tickerSet = new Set((content.match(/\$[A-Z]{2,10}/g) || []).slice(0, 6));
            const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
            let headline = '';
            const hotIdx = lines.findIndex(l => l.toLowerCase().startsWith('**hot now') || l.toLowerCase().startsWith('hot now'));
            if (hotIdx !== -1) {
                headline = lines[hotIdx + 1] || lines[hotIdx];
            }
            if (!headline) {
                const aiPick = lines.find(l => /ai pick/i.test(l));
                headline = aiPick || lines[0] || '';
            }
            headline = headline.replace(/\*\*/g, '').replace(/^[-‚Ä¢\s]+/, '').slice(0, 160);
            return { tickers: Array.from(tickerSet), headline };
        }

        function renderTweet(tweet, isNew = false) {
            const isTest = tweet.isTest || false;
            const username = tweet.username || 'unknown';
            accounts.add(username);

            return `
                <div class="tweet ${isNew ? 'new-tweet' : ''} ${isTest ? 'test-tweet' : ''}" data-id="${tweet.id}">
                    <div class="tweet-header">
                        <div class="tweet-author">
                            <div class="${isTest ? 'test-badge' : 'alpha-badge'}">${isTest ? 'Test' : 'Alpha'}</div>
                            <div class="username">@${username}</div>
                        </div>
                        <div class="tweet-actions">
                            <button class="action-btn" onclick="openTweet('${username}','${tweet.id}')">Open</button>
                            ${tweet.conversation_id && tweet.conversation_id !== tweet.id ? `<button class="action-btn" onclick="openThread('${username}','${tweet.conversation_id}')">Thread</button>` : ''}
                        </div>
                    </div>
                    <div class="tweet-meta">
                        <span>${formatTime(tweet.created_at, tweet.id)} ago</span>
                        <span>ID: ${tweet.id}</span>
                    </div>
                    <div class="tweet-text">${tweet.text}</div>
                    <div class="tweet-metrics">
                        <div class="metric">
                            <span>‚ù§Ô∏è</span>
                            <span>${formatNum(tweet.like_count || 0)}</span>
                        </div>
                        <div class="metric">
                            <span>üîÑ</span>
                            <span>${formatNum(tweet.retweet_count || 0)}</span>
                        </div>
                        <div class="metric">
                            <span>üí¨</span>
                            <span>${formatNum(tweet.reply_count || 0)}</span>
                        </div>
                        <div class="metric">
                            <span>üëÅÔ∏è</span>
                            <span>${formatNum(tweet.impression_count || 0)}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Helper function to re-render all tweets (used for historical tweet insertion)
        function renderAllTweets() {
            const container = document.getElementById('tweetsContent');
            const filteredTweets = filterTweets();
            
            container.innerHTML = filteredTweets
                .map(tweet => renderTweet(tweet, false))
                .join('');
        }

        function openTweet(username, id) {
            window.open(`https://twitter.com/${username}/status/${id}`, '_blank');
        }

        function openThread(username, id) {
            window.open(`https://twitter.com/${username}/status/${id}`, '_blank');
        }

        function updateStats() {
            const totalTweets = allTweets.length;
            const alphaTweets = allTweets.filter(t => !t.isTest).length;
            const testTweets = allTweets.filter(t => t.isTest).length;

            document.getElementById('totalTweets').textContent = totalTweets;
            document.getElementById('alphaTweets').textContent = alphaTweets;
            document.getElementById('testTweets').textContent = testTweets;
            document.getElementById('activeAccounts').textContent = accounts.size;
        }

        function renderAllTweets() {
            const container = document.getElementById('tweetsContent');
            if (allTweets.length === 0) {
                container.innerHTML = '<div class="error-state">No tweets tracked yet...</div>';
                return;
            }

            const filteredTweets = allTweets.filter(tweet => enabledAccounts.has(tweet.username));

            if (filteredTweets.length === 0) {
                container.innerHTML = '<div class="error-state">No tweets from selected accounts...</div>';
                return;
            }

            const sortedTweets = [...filteredTweets].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            container.innerHTML = sortedTweets.map(tweet => renderTweet(tweet)).join('');
            updateStats();
        }

        function setupFilters() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const username = e.target.id.replace('filter-', '');

                    if (e.target.checked) {
                        enabledAccounts.add(username);
                    } else {
                        enabledAccounts.delete(username);
                    }

                    renderAllTweets();
                    console.log('Enabled accounts:', Array.from(enabledAccounts));
                });
            });
        }

        async function loadInitial() {
            try {
                console.log('üîÑ Loading fresh tweets from Twitter API...');
                const response = await fetch('/api/tweets/live');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const tweets = await response.json();

                allTweets = tweets.map(tweet => ({
                    ...tweet,
                    username: tweet.username || 'unknown',
                    isTest: tweet.isTest || false
                }));

                renderAllTweets();
                console.log(`‚úÖ Loaded ${allTweets.length} fresh tweets`);
            } catch (error) {
                console.error('Error loading fresh tweets:', error);
                document.getElementById('tweetsContent').innerHTML = `<div class="error-state">Error loading tweets: ${error.message}</div>`;
            }
        }

        async function refreshLiveData() {
            try {
                console.log('üîÑ Refreshing live tweets...');
                const response = await fetch('/api/tweets/live');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const freshTweets = await response.json();

                allTweets = freshTweets.map(tweet => ({
                    ...tweet,
                    username: tweet.username || 'unknown',
                    isTest: tweet.isTest || false
                }));

                renderAllTweets();
                console.log(`‚úÖ Refreshed with ${allTweets.length} tweets`);
            } catch (error) {
                console.error('Error refreshing:', error);
            }
        }

        async function loadAIInsights() {
            try {
                const res = await fetch('/api/ai/insights');
                if (!res.ok) throw new Error('AI insights not available');
                const data = await res.json();
                if (data.content) {
                    document.getElementById('aiInsights').textContent = data.content;
                    const compact = data.compact || compactFallbackFromContent(data.content);
                    const tickers = compact.tickers || [];
                    const headline = compact.headline || '';

                    const tickersContainer = document.getElementById('aiTickersContainer');
                    if (tickers.length > 0) {
                        tickersContainer.innerHTML = tickers.map(ticker => `<span class="ticker">${ticker}</span>`).join('');
                    } else {
                        tickersContainer.innerHTML = '';
                    }

                    document.getElementById('aiHeadline').textContent = headline || 'Monitoring for alpha signals...';
                } else {
                    document.getElementById('aiTickersContainer').innerHTML = '';
                    document.getElementById('aiHeadline').textContent = 'Monitoring for alpha signals...';
                    document.getElementById('aiInsights').textContent = 'No analysis available yet';
                }
            } catch (e) {
                document.getElementById('aiTickersContainer').innerHTML = '';
                document.getElementById('aiHeadline').textContent = 'Monitoring for alpha signals...';
                document.getElementById('aiInsights').textContent = 'Analysis service unavailable';
            }
        }

        document.getElementById('aiToggle').addEventListener('click', () => {
            const full = document.getElementById('aiInsights');
            const btn = document.getElementById('aiToggle');
            const isHidden = full.style.display === 'none';
            full.style.display = isHidden ? 'block' : 'none';
            btn.textContent = isHidden ? 'Hide Details' : 'Show Details';
        });

        document.getElementById('memoryLink').addEventListener('click', async (e) => {
            e.preventDefault();
            try {
                const res = await fetch('/api/ai/memory');
                if (!res.ok) throw new Error('Failed to load memory');
                const data = await res.json();
                const aiBox = document.getElementById('aiInsights');
                aiBox.style.display = 'block';
                aiBox.innerHTML = '';
                const section = document.createElement('div');
                section.innerHTML = `
                    <div style="margin-bottom:8px; color:#0aa;">Status: ${data.status?.phase}${data.status?.running ? '‚Ä¶' : ''}</div>
                    <div style="margin-bottom:8px;">Latest checksum: ${data.latestInsight?.checksum || '-'}</div>
                    <div style="margin-bottom:8px;">Last 20 Alerts:</div>
                    <ul style="margin:0 0 10px 18px; padding:0;">
                        ${data.notifyHistory.map(h => `<li>[${new Date(h.created_at).toLocaleString()}] ${h.urgency || ''} ${h.message}</li>`).join('')}
                    </ul>
                    <div style="margin-bottom:8px;">Tweets sample (24h):</div>
                `;
                aiBox.appendChild(section);
                const pre = document.createElement('pre');
                pre.style.whiteSpace = 'pre-wrap';
                pre.style.background = 'rgba(0,255,0,0.02)';
                pre.style.border = '1px solid #0f0';
                pre.style.padding = '10px';
                pre.textContent = data.tweets.map(t => `@${t.username} | ${new Date(t.created_at).toISOString()}\n${t.text}\n`).join('\n');
                aiBox.appendChild(pre);
                document.getElementById('aiToggle').textContent = 'Hide full';
            } catch (err) {
                alert('Could not load AI memory');
            }
        });

        // Socket events
        socket.on('connect', () => {
            console.log('Connected to server');
            document.getElementById('connectionStatus').textContent = 'Live';
        });

        socket.on('disconnect', () => {
            console.log('Disconnected');
            document.getElementById('connectionStatus').textContent = 'Offline';
        });

        socket.on('newTweets', (newTweets) => {
            console.log('New tweets:', newTweets);

            newTweets.forEach(tweet => {
                const processedTweet = {
                    ...tweet,
                    username: tweet.username || 'unknown',
                    isTest: tweet.isTest || false
                };

                const existingIndex = allTweets.findIndex(t => t.id === tweet.id);
                if (existingIndex === -1) {
                    allTweets.unshift(processedTweet);

                    const container = document.getElementById('tweetsContent');
                    const newTweetHtml = renderTweet(processedTweet, true);
                    container.insertAdjacentHTML('afterbegin', newTweetHtml);

                    setTimeout(() => {
                        const newTweetEl = container.querySelector('.new-tweet');
                        if (newTweetEl) newTweetEl.classList.remove('new-tweet');
                    }, 3000);
                } else {
                    allTweets[existingIndex] = processedTweet;
                }
            });

            updateStats();
        });

        // Enhanced socket events for proper tweet ordering
        // Live tweets (real-time) - always at top with priority
        socket.on('liveTweets', (liveTweets) => {
            console.log('Live tweets (priority):', liveTweets);
            
            liveTweets.forEach(tweet => {
                const processedTweet = {
                    ...tweet,
                    username: tweet.username || 'unknown',
                    isTest: tweet.isTest || false
                };

                const existingIndex = allTweets.findIndex(t => t.id === tweet.id);
                if (existingIndex === -1) {
                    // ALWAYS insert live tweets at the top (highest priority)
                    allTweets.unshift(processedTweet);

                    const container = document.getElementById('tweetsContent');
                    const newTweetHtml = renderTweet(processedTweet, true);
                    container.insertAdjacentHTML('afterbegin', newTweetHtml);

                    // Enhanced animation for live tweets
                    setTimeout(() => {
                        const newTweetEl = container.querySelector('.new-tweet');
                        if (newTweetEl) {
                            newTweetEl.classList.remove('new-tweet');
                            newTweetEl.style.background = 'rgba(0, 255, 0, 0.1)'; // Live tweet highlight
                            setTimeout(() => {
                                newTweetEl.style.background = '';
                            }, 5000);
                        }
                    }, 100);
                } else {
                    allTweets[existingIndex] = processedTweet;
                }
            });

            updateStats();
        });

        // Historical tweets (backfill) - insert chronologically without disruption
        socket.on('historicalTweets', (historicalTweets) => {
            console.log('Historical tweets (background):', historicalTweets);
            
            historicalTweets.forEach(tweet => {
                const processedTweet = {
                    ...tweet,
                    username: tweet.username || 'unknown',
                    isTest: tweet.isTest || false
                };

                const existingIndex = allTweets.findIndex(t => t.id === tweet.id);
                if (existingIndex === -1) {
                    // Find correct chronological position (don't disrupt live tweets)
                    const tweetTime = new Date(tweet.created_at).getTime();
                    let insertIndex = allTweets.length; // Default to end
                    
                    for (let i = 0; i < allTweets.length; i++) {
                        const existingTime = new Date(allTweets[i].created_at).getTime();
                        if (tweetTime > existingTime) {
                            insertIndex = i;
                            break;
                        }
                    }
                    
                    // Insert at correct chronological position
                    allTweets.splice(insertIndex, 0, processedTweet);
                    
                    // Re-render tweets to maintain order (background operation)
                    setTimeout(() => {
                        renderAllTweets();
                    }, 100);
                }
            });

            updateStats();
        });

        socket.on('aiInsights', async (payload) => {
            const content = payload?.content || '';
            document.getElementById('aiInsights').textContent = content || 'No analysis available yet';
            const compact = payload?.compact || compactFallbackFromContent(content);
            const tickers = compact?.tickers || [];
            const headline = compact?.headline || '';

            // Update prices for tickers and display them
            if (tickers.length > 0) {
                await updateTickerPrices(tickers);

                const tickersContainer = document.getElementById('aiTickersContainer');
                tickersContainer.innerHTML = tickers.map(ticker => renderTickerWithPrice(ticker)).join('');
            } else {
                document.getElementById('aiTickersContainer').innerHTML = '';
            }

            document.getElementById('aiHeadline').textContent = headline || 'Monitoring for alpha signals...';
        });

        // Fetch and update rate limit information
        async function updateRateLimitInfo() {
            try {
                const response = await fetch('/api/rate-limits');
                if (!response.ok) return;
                const aiRes = await fetch('/api/ai/status');
                const aiUsageRes = await fetch('/api/ai/usage');

                const data = await response.json();
                const aiData = aiRes.ok ? await aiRes.json() : null;
                const aiUsageData = aiUsageRes.ok ? await aiUsageRes.json() : null;
                
                // Update API usage in main stats
                let maxUsage = 0;
                let totalQueue = data.queueStatus.length;
                
                Object.values(data.endpoints || {}).forEach(endpoint => {
                    maxUsage = Math.max(maxUsage, endpoint.usagePercentage);
                });
                
                document.getElementById('apiUsage').textContent = `${maxUsage}%`;
                document.getElementById('queueLength').textContent = totalQueue;
                if (aiData) {
                    updateAIStatus(aiData);
                }

                // Update AI usage metrics
                if (aiUsageData) {
                    updateAIUsageMetrics(aiUsageData);
                }

                // Update minimal system status in top bar
                if (Object.keys(data.endpoints || {}).length > 0) {
                    let highestUsage = 0;
                    Object.entries(data.endpoints).forEach(([key, endpoint]) => {
                        highestUsage = Math.max(highestUsage, endpoint.usagePercentage);
                    });

                    const color = highestUsage > 80 ? 'var(--red)' :
                                highestUsage > 60 ? 'var(--orange)' : 'var(--text-subtle)';

                    document.getElementById('planType').textContent = data.plan.toUpperCase();
                    document.getElementById('usagePercent').textContent = `${highestUsage}%`;
                    document.getElementById('usagePercent').style.color = color;
                    document.getElementById('systemStatus').style.display = 'flex';
                }
            } catch (error) {
                console.error('Error fetching rate limit info:', error);
            }
        }

        // Initialize
        loadInitial();
        setupFilters();
        loadAIInsights();

        // Auto-refresh live data every 30 seconds
        setInterval(refreshLiveData, 30000);

        // Update rate limit info every 10 seconds
        setInterval(updateRateLimitInfo, 10000);
        updateRateLimitInfo(); // Initial load

        // Refresh prices for displayed tickers every 2 minutes
        setInterval(async () => {
            const tickersContainer = document.getElementById('aiTickersContainer');
            if (tickersContainer && tickersContainer.children.length > 0) {
                const displayedTickers = Array.from(tickersContainer.children)
                    .map(el => el.textContent.split(' ')[0]) // Get just the ticker symbol
                    .filter(t => t.startsWith('$'));

                if (displayedTickers.length > 0) {
                    const refreshedPrices = await fetchPrices(displayedTickers);
                    if (Object.keys(refreshedPrices).length > 0) {
                        tickersContainer.innerHTML = displayedTickers.map(ticker => renderTickerWithPrice(ticker)).join('');
                    }
                }
            }
        }, 120000); // 2 minutes

        // Webhook Configuration
        let webhookConfig = {
            url: '',
            enabled: false,
            notifications: {
                allTweets: true,
                aiInsights: false,
                highEngagement: false
            },
            accounts: ['cz_binance', 'justinsuntron', 'CookerFlips', 'ShockedJS', 'LabsNoor', 'peacefuldecay']
        };

        function loadWebhookConfig() {
            const saved = localStorage.getItem('webhookConfig');
            if (saved) {
                webhookConfig = { ...webhookConfig, ...JSON.parse(saved) };
                updateWebhookUI();
            }
        }

        function saveWebhookConfig() {
            localStorage.setItem('webhookConfig', JSON.stringify(webhookConfig));
            updateWebhookStatus();
        }

        function updateWebhookUI() {
            document.getElementById('webhookUrl').value = webhookConfig.url || '';
            document.getElementById('notify-all-tweets').checked = webhookConfig.notifications.allTweets;
            document.getElementById('notify-ai-insights').checked = webhookConfig.notifications.aiInsights;
            document.getElementById('notify-high-engagement').checked = webhookConfig.notifications.highEngagement;

            // Update account checkboxes
            webhookConfig.accounts.forEach(account => {
                const checkbox = document.getElementById(`webhook-${account}`);
                if (checkbox) checkbox.checked = true;
            });
        }

        function updateWebhookStatus() {
            const statusEl = document.getElementById('webhookStatus');
            if (webhookConfig.url && webhookConfig.enabled) {
                statusEl.textContent = 'Active';
                statusEl.style.color = 'var(--green)';
            } else if (webhookConfig.url) {
                statusEl.textContent = 'Configured';
                statusEl.style.color = 'var(--orange)';
            } else {
                statusEl.textContent = 'Not configured';
                statusEl.style.color = 'var(--text-dim)';
            }
        }

        async function testWebhook() {
            const url = document.getElementById('webhookUrl').value;
            if (!url) {
                alert('Please enter a webhook URL first');
                return;
            }

            try {
                const response = await fetch('/api/webhook/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                if (response.ok) {
                    alert('Test message sent successfully!');
                } else {
                    alert('Failed to send test message');
                }
            } catch (error) {
                alert('Error testing webhook: ' + error.message);
            }
        }

        async function saveWebhook() {
            const url = document.getElementById('webhookUrl').value;
            if (!url) {
                alert('Please enter a webhook URL');
                return;
            }

            // Update config from form
            webhookConfig.url = url;
            webhookConfig.enabled = true;
            webhookConfig.notifications.allTweets = document.getElementById('notify-all-tweets').checked;
            webhookConfig.notifications.aiInsights = document.getElementById('notify-ai-insights').checked;
            webhookConfig.notifications.highEngagement = document.getElementById('notify-high-engagement').checked;

            // Update accounts
            webhookConfig.accounts = [];
            document.querySelectorAll('#webhookAccounts input[type="checkbox"]:checked').forEach(checkbox => {
                const account = checkbox.id.replace('webhook-', '');
                webhookConfig.accounts.push(account);
            });

            try {
                const response = await fetch('/api/webhook/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(webhookConfig)
                });

                if (response.ok) {
                    saveWebhookConfig();
                    alert('Webhook configuration saved!');
                } else {
                    alert('Failed to save webhook configuration');
                }
            } catch (error) {
                alert('Error saving webhook: ' + error.message);
            }
        }

        // Event listeners
        document.getElementById('webhookToggle').addEventListener('click', () => {
            const config = document.getElementById('webhookConfig');
            const btn = document.getElementById('webhookToggle');
            const isHidden = config.style.display === 'none';
            config.style.display = isHidden ? 'block' : 'none';
            btn.textContent = isHidden ? 'Hide' : 'Configure';
        });

        document.getElementById('testWebhook').addEventListener('click', testWebhook);
        document.getElementById('saveWebhook').addEventListener('click', saveWebhook);

        // Load webhook config on page load
        loadWebhookConfig();
    </script>
</body>
</html>